package br.com.ejb.projetomobile.presenter.impl;

import android.content.res.Resources;
import android.support.annotation.NonNull;

import java.sql.Timestamp;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.TimeZone;

import br.com.ejb.projetomobile.R;
import br.com.ejb.projetomobile.api.PriceAPI;
import br.com.ejb.projetomobile.model.Chart;
import br.com.ejb.projetomobile.model.Value;
import br.com.ejb.projetomobile.presenter.IMainPresenter;
import br.com.ejb.projetomobile.view.IMainActivity;
import lecho.lib.hellocharts.model.Axis;
import lecho.lib.hellocharts.model.Line;
import lecho.lib.hellocharts.model.LineChartData;
import lecho.lib.hellocharts.model.PointValue;
import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;

public class MainPresenter implements IMainPresenter {

    private IMainActivity iMainActivity;
    private PriceAPI priceAPI;
    private SimpleDateFormat sdfSimple = new SimpleDateFormat("dd/MM");
    private SimpleDateFormat sdfFull = new SimpleDateFormat("dd/MM/yyyy");
    private NumberFormat formatter;

    public MainPresenter(IMainActivity iMainActivity) {
        this.iMainActivity = iMainActivity;
        priceAPI = PriceAPI.getInstance();
        sdfSimple.setTimeZone(TimeZone.getTimeZone("GMT"));
        sdfFull.setTimeZone(TimeZone.getTimeZone("GMT"));
        formatter = NumberFormat.getCurrencyInstance(Locale.US);
    }

    /**
     * busca o chart na api e faz a chamada pra atualizar a activity
     *
     * @param timespan timespan selecionado (1 week, 15 days, 30 days)
     */
    @Override
    public void loadCharts(String timespan) {
        iMainActivity.openProgress();
        Call<Chart> request = priceAPI.getAPI().getCharts(timespan);
        request.enqueue(new Callback<Chart>() {
            @Override
            public void onResponse(@NonNull Call<Chart> call, @NonNull Response<Chart> response) {
                iMainActivity.closeProgress();
                if (response.isSuccessful()) {
                    Chart chart = response.body();
                    if (chart != null) {
                        cleanAll();
                        chart.save();
                        Value.saveInTx(chart.getValues());
                        iMainActivity.updateCard(getLastValue());
                        iMainActivity.updateChart(getChartsBD());
                    }
                } else {
                    iMainActivity.showToast(R.string.error_request);
                }
            }

            @Override
            public void onFailure(@NonNull Call<Chart> call, @NonNull Throwable t) {
                iMainActivity.closeProgress();
                iMainActivity.showToast(R.string.error_request);
            }
        });
    }

    /**
     * gera a data para o linechart
     *
     * @param resources resource para pegar a cor
     * @param values    lista das cotacoes selecionadas
     * @return retorna a data para o linechart
     */
    @Override
    public LineChartData generateDataChart(Resources resources, List<Value> values) {
        List<PointValue> pointValues = new ArrayList<>();
        for (Value value : values) {
            PointValue pointValue = new PointValue(value.getX(), ((float) value.getY()));
            pointValue.setLabel(formatter.format(value.getY()) + " - " + convertTimestampToDate(true, value.getX()));
            pointValues.add(pointValue);
        }

        List<Line> lines = new ArrayList<>();
        Line line = new Line(pointValues).setColor(resources.getColor(R.color.colorPrimaryDark));
        line.setHasLabelsOnlyForSelected(true);
        lines.add(line);

        LineChartData data = new LineChartData();
        data.setLines(lines);

        data.setAxisYLeft(new Axis().setAutoGenerated(true).setName(" ").setTextColor(resources.getColor(R.color.colorPrimary)));
        return data;
    }

    /**
     * converte timestamp para o formato de data
     * obs: '000' sao os milisegundos, adicionados para pegar a data corretamente
     *
     * @param isSimple se eh o formato simples ou o completo da data
     * @param value    a cotacao que tera a data convertida
     * @return retorna a data como string no formato selecionado
     */
    public String convertTimestampToDate(boolean isSimple, long value) {
        Timestamp tp = new Timestamp(Long.valueOf(value + "000"));
        Date date = new Date(tp.getTime());
        return isSimple ? sdfSimple.format(date) : sdfFull.format(date);
    }

    /**
     * limpa o banco de dados local
     */
    private void cleanAll() {
        Chart.deleteAll(Chart.class);
        Value.deleteAll(Value.class);
    }

    /**
     * busca as cotacoes no bd na tabela values
     *
     * @return a lista das cotacoes
     */
    private List<Value> getChartsBD() {
        return Value.listAll(Value.class);
    }

    /**
     * busca a ultima cotacao no bd na tabela values
     *
     * @return a ultima cotacao
     */
    private Value getLastValue() {
        return Value.last(Value.class);
    }
}
